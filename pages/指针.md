- `p = &n;` 把 n 的地址赋给 p
- `*p` 表示指向 p 内存位置的那块内容，如果改变 ×p 的值，对应的 n 的值也会发生改变，因为使用指针，直接修改了对应的内存位置的那块内容
- 当然也可以修改 p 所指向的地址，比如 `p = &m;`，那么`*p = m;`
- ```C++
  void f(int x){
  	while(--x > 0){
      	std::cout << x << "\t";
      }
  }
  
  void g(int *x){
  	while(--x > 0){
      	std::cout << x << "\t";
      }
  }
  
  int main(){
  	int n = 5;
      f(n);
      g(&n);
  }
  ```
- 输出：
  ```
  4 3 2 1
  n = 5
  4 3 2 1
  n = 0
  ```
	- 自己的结论：f() 是把 n = 5 传给了 x，但 x 改变和 n 没太大关系
		- 而 g() 是把 n = 5 中 n 的内存地址(即 `&n`)传给了 x，*x 就能通过内存地址直接修改 n 的值(x 指针指向的内容)
- 数组当中的元素是连续存储的，指向 0 号元素的指针地址，+1 就指向了这个数组的 1 号元素
- **只写数组名，则默认指针指向数组第一个元素`int *p = arr`，即 `p = &arr[0]`**
- > 我的理解：& 是内存地址的锁，* 是钥匙，* 有了内存地址之后，就能去开锁
- 利用指针改写 for 循环遍历数组
	- ```C++
	  	  int arr[5] = {1, 3, 5, 7, 9};
	  	  for(int i = 0; i < 5; ++i){
	  	  	std::cout << arr[i] << "\t";
	  	  }
	  	  //等价于下面的写法
	  	  for(int *p = arr; p < arr + 5; ++p){
	  	  	std::cout << *p << "\t";
	  	  }
	  ```
	- 在上面这个 arr 数组中，每个整数的指针地址 + 1，实际上是 + 了 4 个字节
		- 同理换成 double，相邻两个元素之间的地址相差 8 个字节
- 如果是二维数组
	- ```C++
	  	  int arr[2][5] = {1, 3, 5, 7, 9}, {2, 4, 6, 8, 10};
	  	  int *p = arr[0];//&arr[0][0]
	  	  int *q = arr[1];//*arr[1][0]
	  	  //p 和 q 之间相差 5,因为二维数组地址也是相邻的
	  ```
- 定义一个整数数组类型的指针
	- ```C++
	  	  int (*t)[5] = arr;
	  ```
	- `t` 是一个指针，`*t` 取得它所指向的内容，`(*t)[5]` 访问数组内的内容，大小是 5，`int (*t)[5]` 数组里的每个元素都是整数，`int (*t)[5] = arr;` 这个才是 arr 的类型
	- > 当程序只用多维数组的名字时，也会自动将其转换成指向数组首元素的指针
	- arr 是一个由若干个 5 元素整数所构成的数组，对应的指针也是一个有 5 元素整数的指针
	- > 我的理解：*t 的时候已经拿到了对应内存地址的内容了，可是那一块是数组，所以才得给 t 也变成同样的格式（即 `(*t)[5]`），才能读到那一块内容
- ```C++
  #include <iostream>
  using namespace std;
  
  int main(){
  	int arr[3][5] = {{1, 0}, {2, 3, 4}, {5, 6}};
      int (*t)[5] = arr;
      int p = arr;//这个是错的，p 是 int 类型，怎么能等于 arr 首元素的地址呢，必须是指针对应指针
      cout << arr << '\t' << arr + 1 << '\t' << **(arr + 1) << endl;
      cout << t << '\t' << t + 1 << '\t' << **(t + 1) << endl;
      // **(arr + 1) 和 **(t + 1) 的值都是 2,两个 * 因为是多维数组
      
      int arr2[2] = {1, 2};
      int *r = arr2;
      int (*x)[2] = &arr2;
      // 这个右边的意思是 arr 首元素的地址的地址，也可以理解成强行把一维数组变成二维数组
      
      cout << arr2 << endl;
      cout << r << '\t' << *(r + 1) << endl;
      cout << x << '\t' << *(x + 1) << endl;
      //用 15 行的方式，首元素的打印还没什么问题，但到后面的元素就完全是奇怪的东西了
      
  }
  ```
- [[指针初始化]]
- [[成员指针]]
- `int *t = &r;` `&` 指的是取 r 的地址
- `int &r = t;` `&` 指的是用 r 去 [[引用]] t
- ```
  int n = 4;
  int &r = n;
  ```
	- 用 n 和 r 没有快慢之分，两个都是引用
		- 不是用 n 就是直接使用，&r 就是引用，用 n 和用 &r 都是对对象的引用
		- 在这里的引用没有什么用，引用的作用主要体现在函数参数传递的时候
- 函数参数传递引用
	- 一个方法是函数用引用格式，main 函数正常传参数
		- ```
		  		  void swap_r(int &x, int &y){
		  		  	std::cout << __FUNCTION__ << " x = " << x << ", y = " << y << std::endl;
		  		      int t = x;
		  		      x = y;
		  		      y = t;
		  		      std::cout << __FUNCTION__ << " x = " << x << ", y = " << y << std::endl;
		  		  }
		  		  
		  		  int main(){
		  		  	int a = 3, b = 4;
		  		      swap_r(a, b);
		  		      std::cout << __FUNCTION__ << " a = " << a << ", b = " << b << std::endl;
		  		  }
		  ```
	- 另一个方法是函数用指针去访问，main 函数传参数地址
		- ```
		  		  void swap_p(int *x, int *y){
		  		  	std::cout << __FUNCTION__ << " x = " << x << ", y = " << y << std::endl;
		  		      int t = *x;
		  		      *x = *y;
		  		      *y = t;
		  		      std::cout << __FUNCTION__ << " x = " << x << ", y = " << y << std::endl;
		  		  }
		  		  
		  		  int main(){
		  		  	int a = 3, b = 4;
		  		      swap_p(&a, &b);
		  		      std::cout << __FUNCTION__ << " a = " << a << ", b = " << b << std::endl;
		  		  }
		  ```
		- 再次回忆：**调用函数的时候，传递的只是 x 和 y，起到那边才有 `*`**
- 如果一个结构体参数数据非常大，那尽量用引用的形式，不然还得重新拷贝一份到 main 中执行
- 传递常量的引用
	- `void g(const X &b);`
	- `void g(const X *p);`
	- 上面两个都是可读不可写
	- ```
	  	  void g(const X *p){
	  	  	std::cout << (*p).arr[0] << std::endl;
	  	      std::cout << p->arr[0] << std::endl;//上面的简写形式
	  	  }
	  ```
- 指针和对象的区别
	- 引用是对对象的引用，是死死绑定的
		- `X &y = x1;` 一定要引用一个对象才行
	- 但指针可以不指向任何内存地址
		- `X *p = nullptr;` 空指针
		- 但之后可以修改指针的值，让它指向一个地址
- 用指针访问结构体函数
	- `p->function()` 如果有参数列表里面填参数列表
- C++ 中定义一个类型的对象和使用一个对象的语法是一致的
	- `p`首先是一个指针，`*p`然后对它进行引用，`Circle::*p`之后得到的是一个 Circle 类型的字段，`int Circle::*p;` 这个字段的类型是整数类型。即用这个方式定义了指针，这个指针所指向的是 Circle 类型的一个整数成员
- [[this 指针]]
-